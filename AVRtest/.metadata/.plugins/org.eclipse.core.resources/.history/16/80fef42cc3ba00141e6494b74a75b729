//TODO Add Full Row Detection
//DONE Left, Right Piece Movement
//TODO Add Left, Right Collision Detection
//DONE Redefine Pieces For New System
//TODO Add Random Block Spawn
//TODO Add Game Over Logic
//TODO Add Rotation

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/eeprom.h>

#define SIZE 8 //Matrix Size

#define CLK 5 // 2 //Clock
#define DT 3 // 0 //Data
#define LTC 4 // 1 //Latch

volatile uint32_t tm = 0; //Time Counter
volatile uint32_t bTm = 0;

//Display Data
uint8_t tBuffer[SIZE];
uint8_t sBuffer[SIZE]; //Main Rendering Buffer

//Store Tetris Data in EEPROM
uint8_t EEMEM Iblk[5] = { 2, 4,0b11110000, 2,0b10101010 };
uint8_t EEMEM Jblk[9] = { 4, 4,0b10001110, 2,0b11101000, 4,0b11100010, 2,0b01011100 };
uint8_t EEMEM Lblk[9] = { 4, 4,0b00101110, 2,0b10101100, 4,0b11101000, 2,0b11010100 };
uint8_t EEMEM Oblk[3] = { 1, 4,0b11110000 };
uint8_t EEMEM Sblk[5] = { 2, 4,0b01101100, 2,0b10110100 };
uint8_t EEMEM Tblk[9] = { 4, 4,0b01001110, 2,0b10111000, 4,0b11100100, 2,0b01110100 };
uint8_t EEMEM Zblk[5] = { 2, 4,0b11000110, 2,0b01111000 };

uint8_t trs[9]; //Current Tetris Object

uint8_t oldId = 0;
uint8_t id = 0; //Tetris Object Id

uint8_t xS, yS = 0; //XY Position Of Tetris Object
uint8_t oldX,oldY = 0;

uint8_t b = 0; //Collision Boolean

static void Render() {
	int8_t iY, iX = 0; //For Loops Primary XY

	cli(); //Disable Interrupt

	for (iY = 0; iY < SIZE; iY++) {
		for (iX = 7; iX >= 4; iX--) {
			if (((sBuffer[iX] & (1 << (7 - iY))) >> (7 - iY)) == 1)
				PORTB |= _BV(DT);
			else
				PORTB &= ~_BV(DT);

			PORTB |= _BV(CLK); //Clock HIGH
			PORTB &= ~_BV(CLK); //Clock LOW
		}
		for (iX = 3; iX >= 0; iX--) {
			if (iX == iY)
				PORTB &= ~_BV(DT);
			else
				PORTB |= _BV(DT);

			PORTB |= _BV(CLK); //Clock HIGH
			PORTB &= ~_BV(CLK); //Clock LOW
		}

		for (iX = 0; iX < 4; iX++) {
			if (((sBuffer[iX] & (1 << (7 - iY))) >> (7 - iY)) == 1)
				PORTB |= _BV(DT);
			else
				PORTB &= ~_BV(DT);

			PORTB |= _BV(CLK); //Clock HIGH
			PORTB &= ~_BV(CLK); //Clock LOW
		}
		for (iX = 4; iX < 8; iX++) {
			if (iX == iY)
				PORTB &= ~_BV(DT);
			else
				PORTB |= _BV(DT);

			PORTB |= _BV(CLK); //Clock HIGH
			PORTB &= ~_BV(CLK); //Clock LOW
		}

		PORTB |= _BV(LTC); //Latch HIGH
		PORTB &= ~_BV(LTC); //Latch LOW
	}

	sei();  //Disable Interrupt
}

static void RenderB() {
//	cli();

	b = 0;

	//Old Params
	uint8_t s = trs[id + 1] * trs[id + 1]; //Mask Increment Value
	uint8_t sM = s - 1; //Mask Value

	uint8_t sA = 8 - trs[id + 1]; //Shift Ammont
	uint8_t h = (8 / trs[id + 1]); //Height

	cli();
	//Rows Rendering Loop
	while (sM) {
		uint8_t rw = ((trs[id + 2] & sM) << sA) >> oldX; //Apply Mask To Row
		tBuffer[oldY + h - 1] &= ~rw; //Clear Previous Row

		if (xS >= oldX)
			rw = rw >> (xS-oldX);
		else if (xS < oldX)
			rw = rw << (oldX-xS);

		//Collision Check Y
		if ( ((tBuffer[yS + h - 1] & rw) != 0) || ( rw != 0 && (yS+h-1) >= 8) || ( (rw&(1)) != 0 && (xS+trs[id+1]-1) >= 8 ) ) {
			if (oldY != yS) {
				xS = 0; //
				oldX = 0; //Reset Old X

				yS = 0; //Reset Y
				oldY = 0;

				//id = 0; //Set Piece Id
			}

			if (oldX != xS) {
				xS = oldX;
			}

			b = 1;
			break;
		}

		tBuffer[yS + h - 1] |= rw; //Set Temporary Buffer Row

		sA -= trs[id + 1]; //Decrement Shift Amount By Width
		sM *= s; //Increment Mask
		h--; //Decrement Height
	}

	oldId = id;

	oldX = xS; //Save Current X
	oldY = yS; //Save Current Y

	sei();

	//Swap Buffers
	for (int i=0; i<SIZE; i++) {
		if (b==0)
			sBuffer[i] = tBuffer[i];
		else
			tBuffer[i] = sBuffer[i];
	}

//	sei();
}

static void Logic() {
	//RenderB();

	if (b == 0) { //No Y Collision Action
//		if (yS < 4)
//			xS--;
//		else
//			xS++;

		yS++;
	} else { //Y Collision Action
//		xS = 0;
//		oldX = 0;
//
//		yS = 0; //Reset Y
//		id = 2; //Set Piece Id
	}

//	sei();
}

ISR (TIMER0_COMPA_vect) {
	tm++;
	bTm++;
}

//Button1 233
//Button2 42
//Button3 45

#define PVAL 255
uint8_t pCtr=0;

ISR (ADC_vect) {
	if (bTm >= 20) {
		uint8_t st = ADCH;

		if (st == 0b01111110) {
			xS--;
		}

		if (st == 0b11101000) {
			xS++;
		}

		//PORTD = st;
		bTm = 0;
	}

	ADCSRA |= (1 << ADSC);
}

int main(void) {
	DDRB = 0xff; //Set PortB Pins
	DDRD = 0; //Set PortD as output

	//Setup Timer
	TCCR0A |= (1 << WGM01); //Set Timer To CTC Mode
	TCCR0B |= (1 << CS00) | (1 << CS02); //Set Scale Factor To Clk/1024
	OCR0A = 156; //Set Timer Interval
	TIMSK0 |= (1 << OCIE0A); //Set Timer Interrupt On OCR0A Match

	//Setup ADC for Randomization
//	ADMUX |= (1 << MUX0) | (1 << MUX1); //Set Input Pin PB3
//	ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); //Set Division Factor To 128
//	ADCSRA |= (1 << ADEN); //Enable ADC
//	ADCSRA |= (1 << ADSC); //Start Conversion
//	while (ADCSRA & (1 << ADSC)); //Wait until conversion ended
//	uint8_t seed = ADCL; //Generated Random Seed

	//for (int i = 0; i < SIZE; i++) {
	//sBuffer[i] = 0; //seed;
	//seed = ((seed*seed)+seed)%100;
	//}

	//Setup ADC for Button Input
//	ADMUX = 0; //Clear Multiplexer Selection Register
//	ADCSRA = 0; //Clear Control and Status Register A
//
//	ADMUX |= (1 << ADLAR); //(1 << MUX1);
//	ADCSRA |= (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); //Set Division Factor To 128
//	ADCSRA |= (1 << ADEN); //Enable ADC
//	ADCSRA |= (1 << ADIE); //Enable ADC Interupt

	sei();
	//Enable Global Interupt
//	ADCSRA |= (1 << ADSC); //Start ADC

	eeprom_read_block((void*) &trs, (const void*) &Lblk, 9);

	//xS = 5;

	RenderB();

	while (1) {
		//PORTD = b;

		if ((PIND & (1 << 0)) && (bTm >= 25)) {
			xS++;
			bTm = 0;
		} else if ((PIND & (1 << 1)) && (bTm >= 25) && ((xS-1) >= 0) ) {
			xS--;
			bTm = 0;
		} else if ((PIND & (1 << 3)) && (bTm >= 25) ) {
			id+=2;
			bTm = 0;
		}

		if (oldX != xS || oldY != yS || oldId != id || b==1)
			RenderB();

		if (tm > 100) {
			Logic();
			tm = 0;
		}

		Render();

		sBuffer[0] = 0b00001110&(1);
	}

	return 0;
}
